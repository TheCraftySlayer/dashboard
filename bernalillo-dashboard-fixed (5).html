<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bernalillo County Assessor's Office - Performance Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .debug-panel {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            margin: 2rem;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: none;
        }
        
        .debug-panel h2 {
            color: #856404;
            margin-bottom: 1rem;
        }
        
        .debug-content {
            background: #fff;
            border: 1px solid #ffeaa7;
            padding: 1rem;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .upload-section {
            background: white;
            margin: 2rem;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #2a5298;
            background: #f8f9ff;
        }
        
        .upload-area.dragging {
            border-color: #2a5298;
            background: #e8ecff;
        }
        
        input[type="file"] {
            display: none;
        }
        
        /* Time Slider Styles */
        .time-control-section {
            background: white;
            margin: 0 2rem 2rem;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: none;
        }
        
        .time-control-section h3 {
            color: #1e3c72;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        
        /* ROI Calculator Styles */
        .roi-section {
            background: white;
            margin: 0 2rem 2rem;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: none;
        }
        
        .roi-section h3 {
            color: #1e3c72;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
        }
        
        .roi-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .roi-input-group {
            background: #f8f9ff;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        
        .roi-input-group h4 {
            color: #2a5298;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }
        
        .roi-slider-container {
            margin-bottom: 1.5rem;
        }
        
        .roi-slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #666;
        }
        
        .roi-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            transition: background 0.3s;
        }
        
        .roi-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        
        .roi-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .roi-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }
        
        .roi-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #e5e7eb;
        }
        
        .roi-metric {
            text-align: center;
            padding: 1.5rem;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            border-radius: 10px;
            border: 1px solid #d4d9ff;
        }
        
        .roi-metric h5 {
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }
        
        .roi-metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 0.5rem;
        }
        
        .roi-metric-detail {
            font-size: 0.85rem;
            color: #666;
        }
        
        .roi-metric.highlight {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #059669;
        }
        
        .roi-metric.highlight h5,
        .roi-metric.highlight .roi-metric-detail {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .roi-metric.highlight .roi-metric-value {
            color: white;
        }
        
        .slider-container {
            margin: 1.5rem 0;
        }
        
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #666;
        }
        
        .range-slider {
            position: relative;
            height: 40px;
            margin: 1rem 0;
        }
        
        .slider-track {
            position: absolute;
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .slider-range {
            position: absolute;
            height: 6px;
            background: linear-gradient(90deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .slider-thumb {
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #2a5298;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }
        
        .slider-thumb:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        .slider-thumb.dragging {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .date-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9ff;
            border-radius: 8px;
            font-size: 0.95rem;
        }
        
        .date-display span {
            font-weight: 600;
            color: #1e3c72;
        }
        
        .quick-ranges {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .quick-range-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .quick-range-btn:hover {
            background: #f8f9ff;
            border-color: #2a5298;
            color: #1e3c72;
        }
        
        .quick-range-btn.active {
            background: #1e3c72;
            color: white;
            border-color: #1e3c72;
        }
        
        .dashboard {
            padding: 2rem;
            display: grid;
            gap: 2rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .metric-card h3 {
            color: #666;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #1e3c72;
            margin-bottom: 0.5rem;
        }
        
        .metric-change {
            font-size: 0.9rem;
            color: #666;
        }
        
        .metric-change.positive {
            color: #10b981;
        }
        
        .metric-change.negative {
            color: #ef4444;
        }
        
        .chart-container {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .chart-container h2 {
            margin-bottom: 1.5rem;
            color: #1e3c72;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .tab {
            padding: 0.75rem 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab:hover {
            color: #1e3c72;
        }
        
        .tab.active {
            color: #1e3c72;
            border-bottom-color: #1e3c72;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .loading {
            text-align: center;
            padding: 4rem;
            color: #666;
        }
        
        .error {
            background: #fee;
            color: #c00;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
        }
        
        .toggle-debug {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #ffeaa7;
            border: 1px solid #fdcb6e;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .toggle-debug:hover {
            background: #fdcb6e;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard {
                padding: 1rem;
            }
            
            .quick-ranges {
                justify-content: center;
            }
            
            .roi-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Bernalillo County Assessor's Office</h1>
        <p>Performance Analytics Dashboard</p>
    </div>
    
    <button class="toggle-debug" onclick="toggleDebugPanel()">🔍 Toggle Debug</button>
    
    <div class="debug-panel" id="debugPanel">
        <h2>🔍 Debug Information</h2>
        <div class="debug-content" id="debugContent">
            Waiting for Excel file upload...
        </div>
    </div>
    
    <div class="upload-section">
        <h2>Upload Dashboard Data</h2>
        <div class="upload-area" id="uploadArea">
            <p>📁 Drag and drop your Excel file here or click to browse</p>
            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>
        </div>
        <input type="file" id="fileInput" accept=".xlsx" />
        <div id="dataStatus" style="margin-top: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 5px; display: none;">
            <h3 style="margin-bottom: 0.5rem;">Current Data Summary:</h3>
            <div id="dataSummary" style="font-size: 0.9rem; color: #666;"></div>
        </div>
        <p style="margin-top: 1rem; font-size: 0.85rem; color: #666; font-style: italic;">
            Note: Data is processed in-memory only. You'll need to re-upload the Excel file when you refresh or reopen the page.
        </p>
    </div>
    
    <div class="time-control-section" id="timeControlSection">
        <h3>📅 Time Range Filter</h3>
        <div class="slider-container">
            <div class="slider-labels">
                <span id="minDateLabel">Start Date</span>
                <span id="maxDateLabel">End Date</span>
            </div>
            <div class="range-slider" id="rangeSlider">
                <div class="slider-track"></div>
                <div class="slider-range" id="sliderRange"></div>
                <div class="slider-thumb" id="leftThumb" data-thumb="left"></div>
                <div class="slider-thumb" id="rightThumb" data-thumb="right"></div>
            </div>
        </div>
        <div class="date-display">
            <div>Selected Range: <span id="startDateDisplay">-</span> to <span id="endDateDisplay">-</span></div>
            <div>Duration: <span id="durationDisplay">-</span></div>
        </div>
        <div class="quick-ranges">
            <button class="quick-range-btn" data-range="7d">Last 7 Days</button>
            <button class="quick-range-btn" data-range="30d">Last 30 Days</button>
            <button class="quick-range-btn" data-range="90d">Last 90 Days</button>
            <button class="quick-range-btn" data-range="6m">Last 6 Months</button>
            <button class="quick-range-btn" data-range="1y">Last Year</button>
            <button class="quick-range-btn active" data-range="all">All Time</button>
        </div>
    </div>
    
    <div class="roi-section" id="roiSection">
        <h3>💰 ROI Calculator - Service Channel Cost Analysis</h3>
        <div style="background: #e8f5e9; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border: 1px solid #c8e6c9;">
            <p style="margin: 0; font-size: 0.9rem; color: #2e7d32;">
                <strong>Your Configuration:</strong> $13,500/year chatbot cost | $71,064.31/year average staff salary | 
                Staff handle both phone calls and in-person visitors | 8-hour workdays, 40-hour weeks
            </p>
        </div>
        <div class="roi-controls">
            <div class="roi-input-group">
                <h4>Chatbot Costs</h4>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Monthly Chatbot Cost</span>
                        <span>$<span id="chatbotCostValue">1125</span></span>
                    </div>
                    <input type="range" class="roi-slider" id="chatbotCostSlider" min="500" max="3000" value="1125" step="10">
                </div>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Cost per Query (API/Processing)</span>
                        <span>$<span id="queryUnitCostValue">0.10</span></span>
                    </div>
                    <input type="range" class="roi-slider" id="queryUnitCostSlider" min="0.01" max="0.50" value="0.10" step="0.01">
                </div>
            </div>
            
            <div class="roi-input-group">
                <h4>Staff Costs (Phone & In-Person)</h4>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Staff Hourly Rate (w/Benefits)</span>
                        <span>$<span id="staffHourlyRateValue">34.17</span>/hr</span>
                    </div>
                    <input type="range" class="roi-slider" id="staffHourlyRateSlider" min="25" max="50" value="34.17" step="0.01">
                </div>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Facility/Infrastructure Multiplier</span>
                        <span><span id="overheadMultiplierValue">1.0</span>x</span>
                    </div>
                    <input type="range" class="roi-slider" id="overheadMultiplierSlider" min="1.0" max="2.0" value="1.0" step="0.1">
                </div>
            </div>
            
            <div class="roi-input-group">
                <h4>Service Efficiency</h4>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Avg Minutes per Phone Call</span>
                        <span><span id="callMinutesValue">5</span> min</span>
                    </div>
                    <input type="range" class="roi-slider" id="callMinutesSlider" min="2" max="15" value="5" step="0.5">
                </div>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Avg Minutes per In-Person Visit</span>
                        <span><span id="visitMinutesValue">15</span> min</span>
                    </div>
                    <input type="range" class="roi-slider" id="visitMinutesSlider" min="5" max="30" value="15" step="1">
                </div>
                <div class="roi-slider-container">
                    <div class="roi-slider-label">
                        <span>Chatbot Query Deflection Rate</span>
                        <span><span id="deflectionRateValue">30</span>%</span>
                    </div>
                    <input type="range" class="roi-slider" id="deflectionRateSlider" min="10" max="60" value="30" step="5">
                </div>
            </div>
        </div>
        
        <div class="roi-results" id="roiResults">
            <div class="roi-metric">
                <h5>Total Service Cost</h5>
                <div class="roi-metric-value" id="totalServiceCost">$0</div>
                <div class="roi-metric-detail">Across all channels</div>
            </div>
            <div class="roi-metric">
                <h5>Cost per Interaction</h5>
                <div class="roi-metric-value" id="costPerInteraction">$0</div>
                <div class="roi-metric-detail">Weighted average</div>
            </div>
            <div class="roi-metric highlight">
                <h5>Monthly Savings</h5>
                <div class="roi-metric-value" id="monthlySavings">$0</div>
                <div class="roi-metric-detail">From chatbot deflection</div>
            </div>
            <div class="roi-metric">
                <h5>Annual ROI</h5>
                <div class="roi-metric-value" id="annualROI">0%</div>
                <div class="roi-metric-detail">Return on investment</div>
            </div>
            <div class="roi-metric">
                <h5>Staff Hours Saved/Month</h5>
                <div class="roi-metric-value" id="staffHoursSaved">0</div>
                <div class="roi-metric-detail">From chatbot deflection</div>
            </div>
            <div class="roi-metric">
                <h5>FTE Equivalent</h5>
                <div class="roi-metric-value" id="fteEquivalent">0.0</div>
                <div class="roi-metric-detail">Full-time positions saved</div>
            </div>
        </div>
        
        <div class="chart-container" style="margin-top: 2rem;">
            <h2>Service Channel Cost Comparison</h2>
            <div class="chart-wrapper" style="height: 300px;">
                <canvas id="roiComparisonChart"></canvas>
            </div>
        </div>
    </div>
    
    <div class="dashboard" id="dashboard">
        <div class="loading">Loading dashboard data...</div>
    </div>

    <script>
        // Global data storage
        let dashboardData = {
            chatbot: [],
            calls: [],
            visitors: [],
            intelligence: [],
            salaries: []
        };
        
        // Filtered data storage
        let filteredData = {
            chatbot: [],
            calls: [],
            visitors: [],
            intelligence: [],
            salaries: []
        };
        
        // Time range variables
        let dateRange = {
            min: null,
            max: null,
            selectedStart: null,
            selectedEnd: null
        };
        
        // Store chart instances globally
        let chartInstances = {};
        
        // ROI calculation parameters
        let roiParams = {
            chatbotCost: 1125.00, // $13,500/year ÷ 12 months
            queryUnitCost: 0.10,
            staffHourlyRate: 34.17, // $71,064.31/year ÷ 2,080 hours
            overheadMultiplier: 1.0, // Benefits already included in salary
            callMinutes: 5, // Average minutes per call
            visitMinutes: 15, // Average minutes per visit
            deflectionRate: 30
        };
        
        // Debug logging
        let debugLog = [];
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function addDebugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `[${timestamp}] ${message}`;
            if (data) {
                logEntry += '\n' + JSON.stringify(data, null, 2);
            }
            debugLog.push(logEntry);
            
            // Keep only last 100 entries
            if (debugLog.length > 100) {
                debugLog = debugLog.slice(-100);
            }
            
            // Update debug panel
            const debugContent = document.getElementById('debugContent');
            if (debugContent) {
                debugContent.textContent = debugLog.join('\n\n');
                // Auto-scroll to bottom
                debugContent.scrollTop = debugContent.scrollHeight;
            }
        }
        
        // Global helper function to parse dates safely
        function parseDate(dateValue) {
            if (!dateValue) return null;
            
            // If it's already a Date object
            if (dateValue instanceof Date) {
                return moment(dateValue);
            }
            
            // Try parsing with various formats
            const formats = [
                'DD MMM YYYY, HH:mm',
                'YYYY-MM-DD',
                'MM/DD/YYYY',
                'DD/MM/YYYY',
                'YYYY-MM-DD HH:mm:ss',
                'YYYY-MM-DD HH:mm',
                'DD MMM YYYY',
                'MMM DD, YYYY',
                'M/D/YYYY',
                'D/M/YYYY',
                'YYYY/MM/DD',
                'DD-MM-YYYY',
                'MM-DD-YYYY',
                'YYYY.MM.DD',
                'DD.MM.YYYY',
                'DD MMM YY',
                'MMM DD YY',
                'DD MMMM YYYY',
                'MMMM DD, YYYY'
            ];
            
            // Try parsing with specified formats
            for (const format of formats) {
                const parsed = moment(dateValue, format, true);
                if (parsed.isValid()) {
                    return parsed;
                }
            }
            
            // Last resort - let moment try to parse it
            const parsed = moment(dateValue);
            return parsed.isValid() ? parsed : null;
        }
        
        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard initializing...');
            addDebugLog('Dashboard initializing...');
            
            try {
                setupFileUpload();
                setupTimeSlider();
                setupQuickRangeButtons();
                setupTabListeners();
                setupROISliders();
                
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Please upload an Excel file to view the dashboard.</div>';
                    
                console.log('Dashboard initialized successfully');
                addDebugLog('Dashboard initialized successfully');
            } catch (error) {
                console.error('Error during initialization:', error);
                addDebugLog('Error during initialization: ' + error.message);
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error initializing dashboard: ' + error.message + '</div>';
            }
        });
        
        // Setup ROI sliders
        function setupROISliders() {
            // Chatbot cost slider
            const chatbotCostSlider = document.getElementById('chatbotCostSlider');
            chatbotCostSlider.addEventListener('input', function() {
                roiParams.chatbotCost = parseFloat(this.value);
                document.getElementById('chatbotCostValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Query unit cost slider
            const queryUnitCostSlider = document.getElementById('queryUnitCostSlider');
            queryUnitCostSlider.addEventListener('input', function() {
                roiParams.queryUnitCost = parseFloat(this.value);
                document.getElementById('queryUnitCostValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Staff hourly rate slider
            const staffHourlyRateSlider = document.getElementById('staffHourlyRateSlider');
            staffHourlyRateSlider.addEventListener('input', function() {
                roiParams.staffHourlyRate = parseFloat(this.value);
                document.getElementById('staffHourlyRateValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Overhead multiplier slider
            const overheadMultiplierSlider = document.getElementById('overheadMultiplierSlider');
            overheadMultiplierSlider.addEventListener('input', function() {
                roiParams.overheadMultiplier = parseFloat(this.value);
                document.getElementById('overheadMultiplierValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Call minutes slider
            const callMinutesSlider = document.getElementById('callMinutesSlider');
            callMinutesSlider.addEventListener('input', function() {
                roiParams.callMinutes = parseFloat(this.value);
                document.getElementById('callMinutesValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Visit minutes slider
            const visitMinutesSlider = document.getElementById('visitMinutesSlider');
            visitMinutesSlider.addEventListener('input', function() {
                roiParams.visitMinutes = parseFloat(this.value);
                document.getElementById('visitMinutesValue').textContent = this.value;
                updateROICalculations();
            });
            
            // Deflection rate slider
            const deflectionRateSlider = document.getElementById('deflectionRateSlider');
            deflectionRateSlider.addEventListener('input', function() {
                roiParams.deflectionRate = parseFloat(this.value);
                document.getElementById('deflectionRateValue').textContent = this.value;
                updateROICalculations();
            });
        }
        
        // Update ROI calculations
        function updateROICalculations() {
            // Check if we have data to work with
            if (!filteredData || (!filteredData.chatbot.length && !filteredData.calls.length && !filteredData.visitors.length)) {
                addDebugLog('No data available for ROI calculations');
                // Reset displays to zero
                document.getElementById('totalServiceCost').textContent = '$0';
                document.getElementById('costPerInteraction').textContent = '$0.00';
                document.getElementById('monthlySavings').textContent = '$0';
                document.getElementById('annualROI').textContent = '0%';
                document.getElementById('staffHoursSaved').textContent = '0';
                document.getElementById('fteEquivalent').textContent = '0.0';
                return;
            }
            
            // Calculate metrics from filtered data
            const totalDays = dateRange.selectedEnd && dateRange.selectedStart ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const monthlyDays = 30.44; // More accurate average days per month
            
            // Total interactions from actual data
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const totalInteractions = totalQueries + totalCalls + totalVisitors;
            
            addDebugLog('Total interactions calculated', {
                totalQueries,
                totalCalls,
                totalVisitors,
                totalInteractions,
                totalDays
            });
            
            // Calculate staff time costs
            const hourlyRate = roiParams.staffHourlyRate * roiParams.overheadMultiplier;
            const costPerMinute = hourlyRate / 60;
            
            // Cost per interaction type
            const costPerCall = costPerMinute * roiParams.callMinutes;
            const costPerVisit = costPerMinute * roiParams.visitMinutes;
            const costPerQuery = roiParams.queryUnitCost; // Variable cost per query
            
            // Calculate actual monthly averages based on the data period
            const monthlyQueries = (totalQueries / totalDays) * monthlyDays;
            const monthlyCalls = (totalCalls / totalDays) * monthlyDays;
            const monthlyVisitors = (totalVisitors / totalDays) * monthlyDays;
            
            // Monthly costs calculation
            const chatbotFixedCost = roiParams.chatbotCost; // Fixed monthly cost
            const chatbotVariableCost = monthlyQueries * costPerQuery; // Variable cost based on usage
            const chatbotMonthlyCost = chatbotFixedCost + chatbotVariableCost;
            const callCenterMonthlyCost = monthlyCalls * costPerCall;
            const visitorMonthlyCost = monthlyVisitors * costPerVisit;
            
            // Total service cost
            const totalServiceCost = chatbotMonthlyCost + callCenterMonthlyCost + visitorMonthlyCost;
            
            // Cost per interaction
            const monthlyInteractions = monthlyQueries + monthlyCalls + monthlyVisitors;
            const costPerInteraction = monthlyInteractions > 0 ? totalServiceCost / monthlyInteractions : 0;
            
            // Calculate savings from chatbot deflection
            // This represents how many calls/visits the chatbot prevented
            const deflectedCalls = monthlyQueries * (roiParams.deflectionRate / 100);
            const deflectedVisits = monthlyQueries * (roiParams.deflectionRate / 100) * 0.3; // Assume 30% would have been in-person
            
            // Monthly savings = cost of handling deflected interactions through traditional channels
            const callSavings = deflectedCalls * costPerCall;
            const visitSavings = deflectedVisits * costPerVisit;
            const monthlySavings = callSavings + visitSavings;
            
            // Calculate ROI
            const annualSavings = monthlySavings * 12;
            const annualChatbotCost = chatbotFixedCost * 12 + (chatbotVariableCost * 12);
            const annualROI = annualChatbotCost > 0 ? ((annualSavings - annualChatbotCost) / annualChatbotCost) * 100 : 0;
            
            // Calculate staff hours saved
            const callHoursSaved = (deflectedCalls * roiParams.callMinutes) / 60;
            const visitHoursSaved = (deflectedVisits * roiParams.visitMinutes) / 60;
            const monthlyHoursSaved = callHoursSaved + visitHoursSaved;
            const fteEquivalent = monthlyHoursSaved / 173.33; // Average working hours per month
            
            // Update display with actual calculated values
            document.getElementById('totalServiceCost').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) {
                addDebugLog('ROI comparison chart canvas not found');
                return;
            }
            
            // Destroy existing chart if it exists
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            // Create new chart with updated data
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot || 0, costs.calls || 0, costs.visitors || 0],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit || 0, costs.callPerUnit || 0, costs.visitorPerUnit || 0],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    // Ensure ROI is updated after dragging
                    setTimeout(() => {
                        updateROICalculations();
                    }, 150);
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                addDebugLog('No date range selected, using all data');
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            addDebugLog('Data filtered', {
                chatbot: filteredData.chatbot.length,
                calls: filteredData.calls.length,
                visitors: filteredData.visitors.length,
                intelligence: filteredData.intelligence.length
            });
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls - make sure ROI section is visible
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation with loaded data
                    setTimeout(() => {
                        updateROICalculations();
                    }, 200);
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations after charts are initialized
                updateROICalculations();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
                // Also update ROI when switching tabs
                updateROICalculations();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations with new filtered data
                updateROICalculations();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + totalServiceCost.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('costPerInteraction').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + costPerInteraction.toFixed(2);
            document.getElementById('monthlySavings').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + monthlySavings.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('annualROI').textContent = annualROI.toFixed(0) + '%';
            document.getElementById('staffHoursSaved').textContent = monthlyHoursSaved.toFixed(0);
            document.getElementById('fteEquivalent').textContent = fteEquivalent.toFixed(2);
            
            // Update comparison chart with actual data
            updateROIComparisonChart({
                chatbot: chatbotMonthlyCost,
                calls: callCenterMonthlyCost,
                visitors: visitorMonthlyCost,
                chatbotPerUnit: monthlyQueries > 0 ? chatbotMonthlyCost / monthlyQueries : 0,
                callPerUnit: costPerCall,
                visitorPerUnit: costPerVisit
            });
            
            addDebugLog('ROI Calculations Updated', {
                dataRange: {
                    totalDays,
                    monthlyDays,
                    startDate: moment(dateRange.selectedStart).format('YYYY-MM-DD'),
                    endDate: moment(dateRange.selectedEnd).format('YYYY-MM-DD')
                },
                rawCounts: {
                    totalQueries,
                    totalCalls,
                    totalVisitors
                },
                monthlyProjections: {
                    monthlyQueries: monthlyQueries.toFixed(1),
                    monthlyCalls: monthlyCalls.toFixed(1),
                    monthlyVisitors: monthlyVisitors.toFixed(1)
                },
                costs: {
                    hourlyRate: hourlyRate.toFixed(2),
                    costPerMinute: costPerMinute.toFixed(2),
                    costPerCall: costPerCall.toFixed(2),
                    costPerVisit: costPerVisit.toFixed(2),
                    costPerQuery: costPerQuery.toFixed(2)
                },
                monthlyCosts: {
                    chatbotFixed: chatbotFixedCost.toFixed(2),
                    chatbotVariable: chatbotVariableCost.toFixed(2),
                    chatbotTotal: chatbotMonthlyCost.toFixed(2),
                    callCenter: callCenterMonthlyCost.toFixed(2),
                    visitor: visitorMonthlyCost.toFixed(2),
                    total: totalServiceCost.toFixed(2)
                },
                savings: {
                    deflectedCalls: deflectedCalls.toFixed(1),
                    deflectedVisits: deflectedVisits.toFixed(1),
                    callSavings: callSavings.toFixed(2),
                    visitSavings: visitSavings.toFixed(2),
                    monthlySavings: monthlySavings.toFixed(2),
                    annualSavings: annualSavings.toFixed(2)
                },
                roi: {
                    annualROI: annualROI.toFixed(1) + '%',
                    monthlyHoursSaved: monthlyHoursSaved.toFixed(1),
                    fteEquivalent: fteEquivalent.toFixed(2)
                }
            });
        }
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls - make sure ROI section is visible
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation with loaded data
                    setTimeout(() => {
                        updateROICalculations();
                    }, 200);
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations after charts are initialized
                updateROICalculations();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
                // Also update ROI when switching tabs
                updateROICalculations();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations with new filtered data
                updateROICalculations();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + totalServiceCost.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('costPerInteraction').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + costPerInteraction.toFixed(2);
            document.getElementById('monthlySavings').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + monthlySavings.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('annualROI').textContent = annualROI.toFixed(0) + '%';
            document.getElementById('staffHoursSaved').textContent = monthlyHoursSaved.toFixed(0);
            document.getElementById('fteEquivalent').textContent = fteEquivalent.toFixed(2);
            
            // Update comparison chart with actual data
            updateROIComparisonChart({
                chatbot: chatbotMonthlyCost,
                calls: callCenterMonthlyCost,
                visitors: visitorMonthlyCost,
                chatbotPerUnit: monthlyQueries > 0 ? chatbotMonthlyCost / monthlyQueries : 0,
                callPerUnit: costPerCall,
                visitorPerUnit: costPerVisit
            });
            
            addDebugLog('ROI Calculations Updated', {
                dataRange: {
                    totalDays,
                    monthlyDays,
                    startDate: moment(dateRange.selectedStart).format('YYYY-MM-DD'),
                    endDate: moment(dateRange.selectedEnd).format('YYYY-MM-DD')
                },
                rawCounts: {
                    totalQueries,
                    totalCalls,
                    totalVisitors
                },
                monthlyProjections: {
                    monthlyQueries: monthlyQueries.toFixed(1),
                    monthlyCalls: monthlyCalls.toFixed(1),
                    monthlyVisitors: monthlyVisitors.toFixed(1)
                },
                costs: {
                    hourlyRate: hourlyRate.toFixed(2),
                    costPerMinute: costPerMinute.toFixed(2),
                    costPerCall: costPerCall.toFixed(2),
                    costPerVisit: costPerVisit.toFixed(2),
                    costPerQuery: costPerQuery.toFixed(2)
                },
                monthlyCosts: {
                    chatbotFixed: chatbotFixedCost.toFixed(2),
                    chatbotVariable: chatbotVariableCost.toFixed(2),
                    chatbotTotal: chatbotMonthlyCost.toFixed(2),
                    callCenter: callCenterMonthlyCost.toFixed(2),
                    visitor: visitorMonthlyCost.toFixed(2),
                    total: totalServiceCost.toFixed(2)
                },
                savings: {
                    deflectedCalls: deflectedCalls.toFixed(1),
                    deflectedVisits: deflectedVisits.toFixed(1),
                    callSavings: callSavings.toFixed(2),
                    visitSavings: visitSavings.toFixed(2),
                    monthlySavings: monthlySavings.toFixed(2),
                    annualSavings: annualSavings.toFixed(2)
                },
                roi: {
                    annualROI: annualROI.toFixed(1) + '%',
                    monthlyHoursSaved: monthlyHoursSaved.toFixed(1),
                    fteEquivalent: fteEquivalent.toFixed(2)
                }
            });
        }
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
            
            addDebugLog('ROI comparison chart updated', costs);
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls - make sure ROI section is visible
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation with loaded data
                    setTimeout(() => {
                        updateROICalculations();
                    }, 200);
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations after charts are initialized
                updateROICalculations();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
                // Also update ROI when switching tabs
                updateROICalculations();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
                // Update ROI calculations with new filtered data
                updateROICalculations();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + totalServiceCost.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('costPerInteraction').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + costPerInteraction.toFixed(2);
            document.getElementById('monthlySavings').textContent = '
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html> + monthlySavings.toFixed(0).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            document.getElementById('annualROI').textContent = annualROI.toFixed(0) + '%';
            document.getElementById('staffHoursSaved').textContent = monthlyHoursSaved.toFixed(0);
            document.getElementById('fteEquivalent').textContent = fteEquivalent.toFixed(2);
            
            // Update comparison chart with actual data
            updateROIComparisonChart({
                chatbot: chatbotMonthlyCost,
                calls: callCenterMonthlyCost,
                visitors: visitorMonthlyCost,
                chatbotPerUnit: monthlyQueries > 0 ? chatbotMonthlyCost / monthlyQueries : 0,
                callPerUnit: costPerCall,
                visitorPerUnit: costPerVisit
            });
            
            addDebugLog('ROI Calculations Updated', {
                dataRange: {
                    totalDays,
                    monthlyDays,
                    startDate: moment(dateRange.selectedStart).format('YYYY-MM-DD'),
                    endDate: moment(dateRange.selectedEnd).format('YYYY-MM-DD')
                },
                rawCounts: {
                    totalQueries,
                    totalCalls,
                    totalVisitors
                },
                monthlyProjections: {
                    monthlyQueries: monthlyQueries.toFixed(1),
                    monthlyCalls: monthlyCalls.toFixed(1),
                    monthlyVisitors: monthlyVisitors.toFixed(1)
                },
                costs: {
                    hourlyRate: hourlyRate.toFixed(2),
                    costPerMinute: costPerMinute.toFixed(2),
                    costPerCall: costPerCall.toFixed(2),
                    costPerVisit: costPerVisit.toFixed(2),
                    costPerQuery: costPerQuery.toFixed(2)
                },
                monthlyCosts: {
                    chatbotFixed: chatbotFixedCost.toFixed(2),
                    chatbotVariable: chatbotVariableCost.toFixed(2),
                    chatbotTotal: chatbotMonthlyCost.toFixed(2),
                    callCenter: callCenterMonthlyCost.toFixed(2),
                    visitor: visitorMonthlyCost.toFixed(2),
                    total: totalServiceCost.toFixed(2)
                },
                savings: {
                    deflectedCalls: deflectedCalls.toFixed(1),
                    deflectedVisits: deflectedVisits.toFixed(1),
                    callSavings: callSavings.toFixed(2),
                    visitSavings: visitSavings.toFixed(2),
                    monthlySavings: monthlySavings.toFixed(2),
                    annualSavings: annualSavings.toFixed(2)
                },
                roi: {
                    annualROI: annualROI.toFixed(1) + '%',
                    monthlyHoursSaved: monthlyHoursSaved.toFixed(1),
                    fteEquivalent: fteEquivalent.toFixed(2)
                }
            });
        }
        
        // Update ROI comparison chart
        function updateROIComparisonChart(costs) {
            const ctx = document.getElementById('roiComparisonChart')?.getContext('2d');
            if (!ctx) return;
            
            if (chartInstances.roiComparison) {
                chartInstances.roiComparison.destroy();
            }
            
            chartInstances.roiComparison = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Chatbot', 'Call Center', 'In-Person Visits'],
                    datasets: [
                        {
                            label: 'Monthly Cost',
                            data: [costs.chatbot, costs.calls, costs.visitors],
                            backgroundColor: ['#10b981', '#3b82f6', '#f59e0b'],
                            borderRadius: 5
                        },
                        {
                            label: 'Cost per Interaction',
                            data: [costs.chatbotPerUnit, costs.callPerUnit, costs.visitorPerUnit],
                            backgroundColor: ['#059669', '#1d4ed8', '#d97706'],
                            borderRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Setup tab listeners globally
        function setupTabListeners() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab')) {
                    const tabName = e.target.getAttribute('data-tab');
                    switchTab(tabName);
                }
            });
        }
        
        // Setup quick range buttons
        function setupQuickRangeButtons() {
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('quick-range-btn')) {
                    const range = e.target.getAttribute('data-range');
                    setQuickRange(range, e.target);
                }
            });
        }
        
        function setQuickRange(range, button) {
            if (!dateRange.max) return;
            
            // Remove active class from all buttons
            document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
            // Add active class to clicked button
            button.classList.add('active');
            
            let start, end = dateRange.max;
            
            switch(range) {
                case '7d':
                    start = moment(end).subtract(7, 'days').toDate();
                    break;
                case '30d':
                    start = moment(end).subtract(30, 'days').toDate();
                    break;
                case '90d':
                    start = moment(end).subtract(90, 'days').toDate();
                    break;
                case '6m':
                    start = moment(end).subtract(6, 'months').toDate();
                    break;
                case '1y':
                    start = moment(end).subtract(1, 'year').toDate();
                    break;
                case 'all':
                    start = dateRange.min;
                    end = dateRange.max;
                    break;
            }
            
            // Ensure start date is not before min date
            if (start < dateRange.min) {
                start = dateRange.min;
            }
            
            dateRange.selectedStart = start;
            dateRange.selectedEnd = end;
            
            // Update slider position
            updateSliderPosition();
            updateDateDisplay();
            
            // Filter and re-render
            filterDataByDateRange();
            updateCurrentTabCharts();
            updateROICalculations();
        }
        
        function updateSliderPosition() {
            if (!dateRange.min || !dateRange.max) return;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            const startDays = moment(dateRange.selectedStart).diff(moment(dateRange.min), 'days');
            const endDays = moment(dateRange.selectedEnd).diff(moment(dateRange.min), 'days');
            
            const leftPercent = (startDays / totalDays) * 100;
            const rightPercent = (endDays / totalDays) * 100;
            
            document.getElementById('leftThumb').style.left = leftPercent + '%';
            document.getElementById('rightThumb').style.left = rightPercent + '%';
            
            updateSliderRange();
        }
        
        function updateSliderRange() {
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0);
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100);
            
            const sliderRange = document.getElementById('sliderRange');
            sliderRange.style.left = leftPercent + '%';
            sliderRange.style.width = (rightPercent - leftPercent) + '%';
        }
        
        // Setup time slider
        function setupTimeSlider() {
            const rangeSlider = document.getElementById('rangeSlider');
            const leftThumb = document.getElementById('leftThumb');
            const rightThumb = document.getElementById('rightThumb');
            
            let isDragging = false;
            let currentThumb = null;
            
            function startDrag(e) {
                if (e.target.classList.contains('slider-thumb')) {
                    isDragging = true;
                    currentThumb = e.target;
                    currentThumb.classList.add('dragging');
                    e.preventDefault();
                }
            }
            
            function drag(e) {
                if (!isDragging || !currentThumb) return;
                
                const rect = rangeSlider.getBoundingClientRect();
                let x = e.clientX - rect.left;
                x = Math.max(0, Math.min(x, rect.width));
                
                const percent = (x / rect.width) * 100;
                
                if (currentThumb.dataset.thumb === 'left') {
                    const rightPercent = parseFloat(rightThumb.style.left || 100);
                    if (percent < rightPercent - 5) {
                        leftThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                } else {
                    const leftPercent = parseFloat(leftThumb.style.left || 0);
                    if (percent > leftPercent + 5) {
                        rightThumb.style.left = percent + '%';
                        updateSliderRange();
                        updateDateFromSlider();
                    }
                }
            }
            
            function stopDrag() {
                if (currentThumb) {
                    currentThumb.classList.remove('dragging');
                }
                
                if (isDragging && dateRange.selectedStart && dateRange.selectedEnd) {
                    // Clear active state from quick range buttons
                    document.querySelectorAll('.quick-range-btn').forEach(btn => btn.classList.remove('active'));
                    
                    filterDataByDateRange();
                    updateCurrentTabCharts();
                    updateROICalculations();
                }
                
                isDragging = false;
                currentThumb = null;
            }
            
            rangeSlider.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support
            rangeSlider.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                e.target.dispatchEvent(mouseEvent);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    document.dispatchEvent(mouseEvent);
                }
            });
            
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateDateFromSlider() {
            if (!dateRange.min || !dateRange.max) return;
            
            const leftPercent = parseFloat(document.getElementById('leftThumb').style.left || 0) / 100;
            const rightPercent = parseFloat(document.getElementById('rightThumb').style.left || 100) / 100;
            
            const totalDays = moment(dateRange.max).diff(moment(dateRange.min), 'days');
            
            const startDays = Math.round(totalDays * leftPercent);
            const endDays = Math.round(totalDays * rightPercent);
            
            dateRange.selectedStart = moment(dateRange.min).add(startDays, 'days').toDate();
            dateRange.selectedEnd = moment(dateRange.min).add(endDays, 'days').toDate();
            
            updateDateDisplay();
        }
        
        function updateDateDisplay() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) return;
            
            document.getElementById('startDateDisplay').textContent = moment(dateRange.selectedStart).format('MMM DD, YYYY');
            document.getElementById('endDateDisplay').textContent = moment(dateRange.selectedEnd).format('MMM DD, YYYY');
            
            const duration = moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1;
            document.getElementById('durationDisplay').textContent = duration + ' days';
        }
        
        function filterDataByDateRange() {
            if (!dateRange.selectedStart || !dateRange.selectedEnd) {
                filteredData = JSON.parse(JSON.stringify(dashboardData));
                return;
            }
            
            const start = moment(dateRange.selectedStart).startOf('day');
            const end = moment(dateRange.selectedEnd).endOf('day');
            
            addDebugLog(`Filtering data from ${start.format('MMM DD, YYYY')} to ${end.format('MMM DD, YYYY')}`);
            
            // Filter each dataset
            filteredData.chatbot = dashboardData.chatbot.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.calls = dashboardData.calls.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.visitors = dashboardData.visitors.filter(row => {
                const date = parseDate(row.Date);
                if (!date) return false;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            filteredData.intelligence = dashboardData.intelligence.filter(row => {
                if (!row.created_at) return true;
                const date = parseDate(row.created_at);
                if (!date) return true;
                return date.isSameOrAfter(start) && date.isSameOrBefore(end);
            });
            
            // Salaries don't have dates, so always include all
            filteredData.salaries = dashboardData.salaries;
            
            // Update data summary
            showDataSummary();
        }
        
        // File upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            if (!uploadArea || !fileInput) {
                console.error('Upload elements not found');
                return;
            }
            
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('dragging');
            });
            
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('dragging');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
        }
        
        // Handle file processing
        function handleFile(file) {
            console.log('Handling file:', file?.name);
            addDebugLog('Handling file: ' + file?.name);
            
            if (!file) {
                alert('No file selected');
                return;
            }
            
            if (!file.name.endsWith('.xlsx')) {
                alert('Please upload a valid Excel file (.xlsx)');
                return;
            }
            
            // Show loading state
            document.getElementById('dashboard').innerHTML = '<div class="loading">Processing file...</div>';
            
            const reader = new FileReader();
            
            reader.onerror = function() {
                console.error('Error reading file');
                addDebugLog('Error reading file');
                document.getElementById('dashboard').innerHTML = 
                    '<div class="error">Error reading file. Please try again.</div>';
            };
            
            reader.onload = function(e) {
                try {
                    console.log('File loaded, size:', e.target.result.byteLength);
                    addDebugLog('File loaded, size: ' + e.target.result.byteLength + ' bytes');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array', 
                        cellDates: true,
                        dateNF: 'yyyy-mm-dd'
                    });
                    
                    console.log('Workbook sheets:', workbook.SheetNames);
                    addDebugLog('Workbook sheets found: ' + workbook.SheetNames.join(', '));
                    
                    // Process each sheet
                    processSheets(workbook);
                    
                    // Initialize date range
                    initializeDateRange();
                    
                    // Show controls
                    document.getElementById('timeControlSection').style.display = 'block';
                    document.getElementById('roiSection').style.display = 'block';
                    
                    // Set initial filter to all data
                    filteredData = JSON.parse(JSON.stringify(dashboardData));
                    
                    // Render dashboard
                    renderDashboard();
                    
                    // Initial ROI calculation
                    updateROICalculations();
                    
                    // Show success message
                    const uploadArea = document.getElementById('uploadArea');
                    uploadArea.innerHTML = '<p>✅ Data loaded successfully! Upload a new file to update.</p>';
                    setTimeout(() => {
                        uploadArea.innerHTML = '<p>📁 Drag and drop your Excel file here or click to browse</p><p style="margin-top: 0.5rem; font-size: 0.9rem; color: #666;">Accepts .xlsx files</p>';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    addDebugLog('Error processing file: ' + error.message);
                    document.getElementById('dashboard').innerHTML = 
                        `<div class="error">Error processing file: ${error.message}. Please check the file format and try again.</div>`;
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Initialize date range from data
        function initializeDateRange() {
            let allDates = [];
            
            // Collect all dates from data
            dashboardData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            dashboardData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) allDates.push(date.toDate());
            });
            
            // Also include intelligence dates
            dashboardData.intelligence.forEach(row => {
                const date = parseDate(row.created_at);
                if (date) allDates.push(date.toDate());
            });
            
            addDebugLog(`Found ${allDates.length} valid dates across all datasets`);
            
            if (allDates.length > 0) {
                dateRange.min = new Date(Math.min(...allDates));
                dateRange.max = new Date(Math.max(...allDates));
                dateRange.selectedStart = dateRange.min;
                dateRange.selectedEnd = dateRange.max;
                
                addDebugLog(`Date range initialized: ${moment(dateRange.min).format('MMM DD, YYYY')} to ${moment(dateRange.max).format('MMM DD, YYYY')}`);
                
                // Update slider labels
                document.getElementById('minDateLabel').textContent = moment(dateRange.min).format('MMM DD, YYYY');
                document.getElementById('maxDateLabel').textContent = moment(dateRange.max).format('MMM DD, YYYY');
                
                // Position thumbs
                document.getElementById('leftThumb').style.left = '0%';
                document.getElementById('rightThumb').style.left = '100%';
                updateSliderRange();
                updateDateDisplay();
                
                // Set "All Time" as active
                document.querySelectorAll('.quick-range-btn').forEach(btn => {
                    if (btn.getAttribute('data-range') === 'all') {
                        btn.classList.add('active');
                    }
                });
            }
        }
        
        // Process Excel sheets with enhanced debugging
        function processSheets(workbook) {
            console.log('Processing sheets:', workbook.SheetNames);
            addDebugLog('Processing sheets...');
            
            // Reset data
            dashboardData = {
                chatbot: [],
                calls: [],
                visitors: [],
                intelligence: [],
                salaries: []
            };
            
            // Process Chatbot Numbers
            if (workbook.SheetNames.includes('Chatbot_numbers')) {
                const sheet = workbook.Sheets['Chatbot_numbers'];
                dashboardData.chatbot = XLSX.utils.sheet_to_json(sheet);
                console.log('Chatbot data loaded:', dashboardData.chatbot.length, 'rows');
                addDebugLog(`Chatbot data: ${dashboardData.chatbot.length} rows`);
            }
            
            // Process In-depth Call Data
            if (workbook.SheetNames.includes('indepth_call_data')) {
                const sheet = workbook.Sheets['indepth_call_data'];
                dashboardData.calls = XLSX.utils.sheet_to_json(sheet);
                console.log('Call data loaded:', dashboardData.calls.length, 'rows');
                addDebugLog(`Call data: ${dashboardData.calls.length} rows`);
                
                // Log the columns found in call data for debugging
                if (dashboardData.calls.length > 0) {
                    console.log('Call data columns:', Object.keys(dashboardData.calls[0]));
                    addDebugLog('Call data columns: ' + Object.keys(dashboardData.calls[0]).join(', '));
                }
            }
            
            // Process Visitor Count
            if (workbook.SheetNames.includes('In person Visitor Count')) {
                const sheet = workbook.Sheets['In person Visitor Count'];
                dashboardData.visitors = XLSX.utils.sheet_to_json(sheet);
                console.log('Visitor data loaded:', dashboardData.visitors.length, 'rows');
                addDebugLog(`Visitor data: ${dashboardData.visitors.length} rows`);
            }
            
            // Process Customer Intelligence
            let intelligenceSheetName = null;
            
            // Check for exact match first
            if (workbook.SheetNames.includes('customer_intelligence_chatbot')) {
                intelligenceSheetName = 'customer_intelligence_chatbot';
            } else {
                // Look for any sheet containing "intelligence" or "customer"
                intelligenceSheetName = workbook.SheetNames.find(name => 
                    name.toLowerCase().includes('intelligence') || 
                    name.toLowerCase().includes('customer')
                );
            }
            
            if (intelligenceSheetName) {
                addDebugLog(`Found intelligence sheet: "${intelligenceSheetName}"`);
                const sheet = workbook.Sheets[intelligenceSheetName];
                dashboardData.intelligence = XLSX.utils.sheet_to_json(sheet);
                console.log('Intelligence data loaded:', dashboardData.intelligence.length, 'rows');
                addDebugLog(`Intelligence data: ${dashboardData.intelligence.length} rows`);
                
                // Log the first few rows to see the structure
                if (dashboardData.intelligence.length > 0) {
                    const columns = Object.keys(dashboardData.intelligence[0]);
                    addDebugLog('Intelligence data columns: ' + columns.join(', '));
                }
            } else {
                addDebugLog('WARNING: No customer intelligence sheet found!');
            }
            
            // Process Salaries
            if (workbook.SheetNames.includes('salaries')) {
                const sheet = workbook.Sheets['salaries'];
                dashboardData.salaries = XLSX.utils.sheet_to_json(sheet);
                console.log('Salaries data loaded:', dashboardData.salaries.length, 'rows');
                addDebugLog(`Salaries data: ${dashboardData.salaries.length} rows`);
            }
            
            // Check if we have at least some data
            const hasData = Object.values(dashboardData).some(arr => arr.length > 0);
            if (!hasData) {
                console.error('No data found in any expected sheets');
                addDebugLog('ERROR: No data found in any expected sheets');
                throw new Error('No recognized data sheets found in the Excel file. Please ensure the file contains sheets named: Chatbot_numbers, indepth_call_data, In person Visitor Count, customer_intelligence_chatbot, or salaries.');
            }
        }
        
        // Render the complete dashboard
        function renderDashboard() {
            const dashboard = document.getElementById('dashboard');
            
            // Show data summary
            showDataSummary();
            
            dashboard.innerHTML = `
                <div class="tabs">
                    <button class="tab active" data-tab="overview">Overview</button>
                    <button class="tab" data-tab="chatbot">Chatbot Analytics</button>
                    <button class="tab" data-tab="calls">Call Center</button>
                    <button class="tab" data-tab="visitors">Visitor Trends</button>
                    <button class="tab" data-tab="intelligence">Customer Intelligence</button>
                </div>
                
                <div id="overview" class="tab-content active">
                    ${renderOverview()}
                </div>
                
                <div id="chatbot" class="tab-content">
                    ${renderChatbotAnalytics()}
                </div>
                
                <div id="calls" class="tab-content">
                    ${renderCallAnalytics()}
                </div>
                
                <div id="visitors" class="tab-content">
                    ${renderVisitorAnalytics()}
                </div>
                
                <div id="intelligence" class="tab-content">
                    ${renderCustomerIntelligence()}
                </div>
            `;
            
            // Initialize charts after DOM is updated
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Switch between tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Reinitialize charts for the active tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Update charts without re-rendering entire dashboard
        function updateCurrentTabCharts() {
            // Show updated data summary
            showDataSummary();
            
            // Just reinitialize charts for the current tab
            setTimeout(() => {
                initializeCharts();
            }, 100);
        }
        
        // Show data summary
        function showDataSummary() {
            const dataStatus = document.getElementById('dataStatus');
            const dataSummary = document.getElementById('dataSummary');
            
            if (!dataStatus || !dataSummary) return;
            
            if (filteredData.chatbot.length > 0 || filteredData.calls.length > 0 || filteredData.visitors.length > 0) {
                const dateRangeInfo = getDateRange();
                
                // Calculate total abandoned vs total calls for display
                let totalAbandoned = 0;
                let totalCalls = 0;
                filteredData.calls.forEach(row => {
                    totalAbandoned += row.Abandoned || 0;
                    totalCalls += row.total_calls || 0;
                });
                const overallAbandonmentRate = totalCalls > 0 ? ((totalAbandoned / totalCalls) * 100).toFixed(1) : 0;
                
                const summary = `
                    <strong>Date Range:</strong> ${dateRangeInfo.start} to ${dateRangeInfo.end}<br>
                    <strong>Chatbot Records:</strong> ${filteredData.chatbot.length.toLocaleString()} of ${dashboardData.chatbot.length.toLocaleString()}<br>
                    <strong>Call Records:</strong> ${filteredData.calls.length.toLocaleString()} of ${dashboardData.calls.length.toLocaleString()}<br>
                    <strong>Total Calls:</strong> ${totalCalls.toLocaleString()} (${totalAbandoned.toLocaleString()} abandoned = ${overallAbandonmentRate}%)<br>
                    <strong>Visitor Records:</strong> ${filteredData.visitors.length.toLocaleString()} of ${dashboardData.visitors.length.toLocaleString()}<br>
                    <strong>Chat Conversations:</strong> ${filteredData.intelligence.length.toLocaleString()} of ${dashboardData.intelligence.length.toLocaleString()}<br>
                    <strong>Staff Members:</strong> ${filteredData.salaries.length}
                `;
                dataSummary.innerHTML = summary;
                dataStatus.style.display = 'block';
            }
        }
        
        // Get date range from filtered data
        function getDateRange() {
            if (dateRange.selectedStart && dateRange.selectedEnd) {
                return {
                    start: moment(dateRange.selectedStart).format('MM/DD/YYYY'),
                    end: moment(dateRange.selectedEnd).format('MM/DD/YYYY')
                };
            }
            
            return { start: 'N/A', end: 'N/A' };
        }
        
        // Render Overview Tab
        function renderOverview() {
            const metrics = calculateKeyMetrics();
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Chatbot Queries</h3>
                        <div class="metric-value">${metrics.totalQueries.toLocaleString()}</div>
                        <div class="metric-change ${metrics.queryGrowth >= 0 ? 'positive' : 'negative'}">
                            ${metrics.queryGrowth >= 0 ? '↑' : '↓'} ${Math.abs(metrics.queryGrowth)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Calls Handled</h3>
                        <div class="metric-value">${metrics.totalCalls.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgCallsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Total Visitors</h3>
                        <div class="metric-value">${metrics.totalVisitors.toLocaleString()}</div>
                        <div class="metric-change">Avg ${metrics.avgVisitorsPerDay}/day</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Call Abandonment Rate</h3>
                        <div class="metric-value">${metrics.abandonmentRate}%</div>
                        <div class="metric-change ${metrics.abandonmentTrend <= 0 ? 'positive' : 'negative'}">
                            ${metrics.abandonmentTrend <= 0 ? '↓' : '↑'} ${Math.abs(metrics.abandonmentTrend)}% vs previous period
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Staff Efficiency</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedPercent}%</div>
                        <div class="metric-change ${staffingMetrics.understaffedPercent > 20 ? 'negative' : ''}">
                            ${staffingMetrics.understaffedDays} days total
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Service Channel Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="overviewTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Monthly Performance Summary</h2>
                    <div class="chart-wrapper">
                        <canvas id="monthlyPerformanceChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Chatbot Analytics Tab
        function renderChatbotAnalytics() {
            return `
                <div class="chart-container">
                    <h2>Chatbot Usage Over Time</h2>
                    <div class="chart-wrapper">
                        <canvas id="chatbotUsageChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Queries per Conversation</h2>
                    <div class="chart-wrapper">
                        <canvas id="queriesPerConversationChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Cost Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="costAnalysisChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Call Analytics Tab
        function renderCallAnalytics() {
            const staffingMetrics = calculateStaffingMetrics();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Average Calls per Staff</h3>
                        <div class="metric-value">${staffingMetrics.avgCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change ${staffingMetrics.efficiencyTrend >= 0 ? 'negative' : 'positive'}">
                            ${staffingMetrics.efficiencyTrend >= 0 ? '↑' : '↓'} ${Math.abs(staffingMetrics.efficiencyTrend)}% workload
                        </div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Peak Hour Load</h3>
                        <div class="metric-value">${staffingMetrics.peakCallsPerStaff.toFixed(1)}</div>
                        <div class="metric-change">calls per staff member</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Understaffed Days</h3>
                        <div class="metric-value">${staffingMetrics.understaffedDays}</div>
                        <div class="metric-change">${staffingMetrics.understaffedPercent}% of period</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Staffing Efficiency Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily call volume vs. staff levels. Red areas indicate potential understaffing (>15 calls/staff).
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="staffingEfficiencyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Distribution & Workload</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Calls per Staff Member</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="workloadDistributionChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 style="font-size: 1rem; color: #666; margin-bottom: 1rem;">Staff Utilization Pattern</h3>
                            <div style="position: relative; height: 300px;">
                                <canvas id="utilizationPatternChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Call Outcomes Distribution</h2>
                    <div class="chart-wrapper">
                        <canvas id="callOutcomesChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Abandonment Rate Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Daily abandonment rates with staffing overlay. High abandonment often correlates with understaffing.
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="abandonmentRateChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Average Handle Time (AHT) Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="ahtChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Visitor Analytics Tab
        function renderVisitorAnalytics() {
            return `
                <div class="chart-container">
                    <h2>In-Person Visitor Trends</h2>
                    <div class="chart-wrapper">
                        <canvas id="visitorTrendsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>Day of Week Analysis</h2>
                    <div class="chart-wrapper">
                        <canvas id="dayOfWeekChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Render Customer Intelligence Tab
        function renderCustomerIntelligence() {
            const intents = analyzeIntents();
            const emotions = analyzeEmotions();
            
            return `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Total Conversations</h3>
                        <div class="metric-value">${filteredData.intelligence.length.toLocaleString()}</div>
                        <div class="metric-change" style="font-size: 0.8rem;">of ${dashboardData.intelligence.length.toLocaleString()} total</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Top Intent</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${intents[0]?.intent || 'N/A'}</div>
                        <div class="metric-change">${intents[0]?.count || 0} occurrences</div>
                    </div>
                    
                    <div class="metric-card">
                        <h3>Dominant Emotion</h3>
                        <div class="metric-value" style="font-size: 1.5rem;">${emotions[0]?.emotion || 'N/A'}</div>
                        <div class="metric-change">${emotions[0]?.percentage || 0}% of interactions</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Intent Distribution</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${intents.length} unique intents from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="intentChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h2>User Emotion Analysis</h2>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Showing ${emotions.length} unique emotions from ${filteredData.intelligence.length} conversations
                    </p>
                    <div class="chart-wrapper">
                        <canvas id="emotionChart"></canvas>
                    </div>
                </div>
            `;
        }
        
        // Calculate staffing metrics
        function calculateStaffingMetrics() {
            if (filteredData.calls.length === 0) {
                return {
                    avgCallsPerStaff: 0,
                    peakCallsPerStaff: 0,
                    understaffedDays: 0,
                    understaffedPercent: 0,
                    efficiencyTrend: 0
                };
            }
            
            // Calculate calls per staff for each day
            const dailyMetrics = filteredData.calls.map(row => ({
                date: parseDate(row.Date),
                calls: row.total_calls || 0,
                staff: row.total_staff_count || 1,
                callsPerStaff: (row.total_calls || 0) / (row.total_staff_count || 1)
            }));
            
            // Average calls per staff
            const avgCallsPerStaff = dailyMetrics.reduce((sum, d) => sum + d.callsPerStaff, 0) / dailyMetrics.length;
            
            // Peak calls per staff
            const peakCallsPerStaff = Math.max(...dailyMetrics.map(d => d.callsPerStaff));
            
            // Understaffed days (>15 calls per staff member)
            const understaffedThreshold = 15;
            const understaffedDays = dailyMetrics.filter(d => d.callsPerStaff > understaffedThreshold).length;
            const understaffedPercent = Math.round((understaffedDays / dailyMetrics.length) * 100);
            
            // Efficiency trend (compare first half to second half)
            const midpoint = Math.floor(dailyMetrics.length / 2);
            const firstHalf = dailyMetrics.slice(0, midpoint);
            const secondHalf = dailyMetrics.slice(midpoint);
            
            const firstHalfAvg = firstHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / firstHalf.length;
            const secondHalfAvg = secondHalf.reduce((sum, d) => sum + d.callsPerStaff, 0) / secondHalf.length;
            const efficiencyTrend = Math.round(((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100);
            
            return {
                avgCallsPerStaff,
                peakCallsPerStaff,
                understaffedDays,
                understaffedPercent,
                efficiencyTrend
            };
        }
        
        // Calculate key metrics (updated to use filtered data)
        function calculateKeyMetrics() {
            const now = new Date();
            const totalDays = filteredData.chatbot.length > 0 ? 
                moment(dateRange.selectedEnd).diff(moment(dateRange.selectedStart), 'days') + 1 : 1;
            const halfwayPoint = moment(dateRange.selectedStart).add(totalDays / 2, 'days');
            
            // Chatbot metrics
            const totalQueries = filteredData.chatbot.reduce((sum, row) => sum + (row.query_count || 0), 0);
            const firstHalfQueries = filteredData.chatbot
                .filter(row => {
                    const date = parseDate(row.Date);
                    return date && date.isBefore(halfwayPoint);
                })
                .reduce((sum, row) => sum + (row.query_count || 0), 0);
            const secondHalfQueries = totalQueries - firstHalfQueries;
            const queryGrowth = firstHalfQueries > 0 ? Math.round(((secondHalfQueries - firstHalfQueries) / firstHalfQueries) * 100) : 0;
            
            // Call metrics
            const totalCalls = filteredData.calls.reduce((sum, row) => sum + (row.total_calls || 0), 0);
            const avgCallsPerDay = filteredData.calls.length > 0 ? Math.round(totalCalls / filteredData.calls.length) : 0;
            
            // Visitor metrics
            const totalVisitors = filteredData.visitors.reduce((sum, row) => sum + (row.in_person_visitor_count || 0), 0);
            const avgVisitorsPerDay = filteredData.visitors.length > 0 ? Math.round(totalVisitors / filteredData.visitors.length) : 0;
            
            // Abandonment rate - calculate from actual call outcomes
            const recentCalls = filteredData.calls.slice(-Math.min(30, filteredData.calls.length));
            let recentAbandoned = 0;
            let recentTotal = 0;
            
            recentCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                recentAbandoned += abandoned;
                recentTotal += total;
            });
            
            const abandonmentRate = recentTotal > 0 ? Math.round((recentAbandoned / recentTotal) * 100) : 0;
            
            // Calculate older period for trend
            const olderCalls = filteredData.calls.slice(0, Math.max(0, filteredData.calls.length - 30));
            let olderAbandoned = 0;
            let olderTotal = 0;
            
            olderCalls.forEach(row => {
                const abandoned = row.Abandoned || 0;
                const total = row.total_calls || 0;
                olderAbandoned += abandoned;
                olderTotal += total;
            });
            
            const olderAbandonment = olderTotal > 0 ? (olderAbandoned / olderTotal) * 100 : 0;
            const abandonmentTrend = Math.round(abandonmentRate - olderAbandonment);
            
            return {
                totalQueries,
                queryGrowth,
                totalCalls,
                avgCallsPerDay,
                totalVisitors,
                avgVisitorsPerDay,
                abandonmentRate,
                abandonmentTrend
            };
        }
        
        // Analyze user intents
        function analyzeIntents() {
            const intentCounts = {};
            
            // Try different possible field names for intent
            const possibleIntentFields = ['user_intent', 'intent', 'Intent', 'User Intent', 'USER_INTENT'];
            let intentField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleIntentFields) {
                    if (field in firstRow) {
                        intentField = field;
                        break;
                    }
                }
            }
            
            if (intentField) {
                filteredData.intelligence.forEach(row => {
                    const intent = row[intentField];
                    if (intent) {
                        intentCounts[intent] = (intentCounts[intent] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(intentCounts)
                .map(([intent, count]) => ({ intent, count }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Analyze user emotions
        function analyzeEmotions() {
            const emotionCounts = {};
            const total = filteredData.intelligence.length || 1;
            
            // Try different possible field names for emotion
            const possibleEmotionFields = ['user_emotion', 'emotion', 'Emotion', 'User Emotion', 'USER_EMOTION'];
            let emotionField = null;
            
            if (filteredData.intelligence.length > 0) {
                const firstRow = filteredData.intelligence[0];
                for (const field of possibleEmotionFields) {
                    if (field in firstRow) {
                        emotionField = field;
                        break;
                    }
                }
            }
            
            if (emotionField) {
                filteredData.intelligence.forEach(row => {
                    const emotion = row[emotionField];
                    if (emotion) {
                        emotionCounts[emotion] = (emotionCounts[emotion] || 0) + 1;
                    }
                });
            }
            
            return Object.entries(emotionCounts)
                .map(([emotion, count]) => ({ 
                    emotion, 
                    count,
                    percentage: Math.round((count / total) * 100)
                }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize all charts
        function initializeCharts() {
            // Destroy existing charts
            Object.values(chartInstances).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            chartInstances = {};
            
            // Initialize charts based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            
            const activeTabId = activeTab.id;
            
            switch(activeTabId) {
                case 'overview':
                    createOverviewCharts();
                    break;
                case 'chatbot':
                    createChatbotCharts();
                    break;
                case 'calls':
                    createCallCharts();
                    break;
                case 'visitors':
                    createVisitorCharts();
                    break;
                case 'intelligence':
                    createIntelligenceCharts();
                    break;
            }
        }
        
        // Create overview charts
        function createOverviewCharts() {
            // Service Channel Trends
            const ctx1 = document.getElementById('overviewTrendsChart')?.getContext('2d');
            if (ctx1) {
                const maxDays = Math.max(filteredData.chatbot.length, filteredData.calls.length, filteredData.visitors.length);
                
                if (maxDays > 0) {
                    const dates = filteredData.chatbot.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const chatbotData = filteredData.chatbot.map(row => row.query_count || 0);
                    const callData = filteredData.calls.map(row => row.total_calls || 0);
                    const visitorData = filteredData.visitors.map(row => row.in_person_visitor_count || 0);
                    
                    chartInstances.overviewTrends = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [
                                {
                                    label: 'Chatbot Queries',
                                    data: chatbotData,
                                    borderColor: '#3b82f6',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'Phone Calls',
                                    data: callData,
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    tension: 0.3
                                },
                                {
                                    label: 'In-Person Visitors',
                                    data: visitorData,
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    tension: 0.3
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                },
                                title: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Monthly Performance Summary
            const ctx2 = document.getElementById('monthlyPerformanceChart')?.getContext('2d');
            if (ctx2) {
                const monthlyData = aggregateMonthlyData();
                
                if (monthlyData.labels.length > 0) {
                    chartInstances.monthlyPerformance = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: monthlyData.labels,
                            datasets: [
                                {
                                    label: 'Total Interactions',
                                    data: monthlyData.totals,
                                    backgroundColor: '#1e3c72',
                                    borderRadius: 5
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create chatbot charts
        function createChatbotCharts() {
            // Usage over time
            const ctx1 = document.getElementById('chatbotUsageChart')?.getContext('2d');
            if (ctx1 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.query_count > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const queries = data.map(row => row.query_count);
                const conversations = data.map(row => row.conversation_count);
                
                chartInstances.chatbotUsage = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Queries',
                                data: queries,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                yAxisID: 'y',
                            },
                            {
                                label: 'Conversations',
                                data: conversations,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                yAxisID: 'y1',
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: {
                                    drawOnChartArea: false,
                                },
                            },
                        }
                    }
                });
            }
            
            // Queries per conversation
            const ctx2 = document.getElementById('queriesPerConversationChart')?.getContext('2d');
            if (ctx2 && filteredData.chatbot.length > 0) {
                const data = filteredData.chatbot.filter(row => row.queries_per_conversation > 0);
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const qpc = data.map(row => row.queries_per_conversation);
                
                chartInstances.queriesPerConv = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: 'Queries per Conversation',
                            data: qpc,
                            backgroundColor: '#8b5cf6',
                            borderRadius: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Cost analysis
            const ctx3 = document.getElementById('costAnalysisChart')?.getContext('2d');
            if (ctx3 && filteredData.chatbot.length > 0) {
                const monthlyQueries = {};
                filteredData.chatbot.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const month = date.format('YYYY-MM');
                        monthlyQueries[month] = (monthlyQueries[month] || 0) + (row.query_count || 0);
                    }
                });
                
                const months = Object.keys(monthlyQueries).sort();
                const costPerQuery = 36.99 / 30; // Daily cost divided by average queries
                const costs = months.map(month => {
                    const queries = monthlyQueries[month];
                    return queries > 0 ? (36.99 * 30) / queries : 0;
                });
                
                chartInstances.costAnalysis = new Chart(ctx3, {
                    type: 'line',
                    data: {
                        labels: months.map(m => moment(m).format('MMM YYYY')),
                        datasets: [{
                            label: 'Cost per Query ($)',
                            data: costs,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Create call center charts
        function createCallCharts() {
            // Staffing Efficiency Chart
            const ctx1 = document.getElementById('staffingEfficiencyChart')?.getContext('2d');
            if (ctx1 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const calls = data.map(row => row.total_calls || 0);
                const staff = data.map(row => row.total_staff_count || 1);
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create background colors based on efficiency
                const backgroundColors = callsPerStaff.map(ratio => {
                    if (ratio > 20) return 'rgba(239, 68, 68, 0.7)'; // Red - severely understaffed
                    if (ratio > 15) return 'rgba(251, 146, 60, 0.7)'; // Orange - understaffed
                    if (ratio > 10) return 'rgba(250, 204, 21, 0.7)'; // Yellow - busy
                    return 'rgba(34, 197, 94, 0.7)'; // Green - well-staffed
                });
                
                chartInstances.staffingEfficiency = new Chart(ctx1, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Call Volume',
                                data: calls,
                                backgroundColor: backgroundColors,
                                borderColor: backgroundColors.map(c => c.replace('0.7', '1')),
                                borderWidth: 1,
                                borderRadius: 3,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Staff on Duty',
                                data: staff,
                                type: 'line',
                                borderColor: '#1e3c72',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: '#1e3c72',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const ratio = callsPerStaff[index].toFixed(1);
                                            return `Calls per Staff: ${ratio}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Call Volume'
                                }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Staff Count'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                }
                            }
                        }
                    }
                });
            }
            
            // Workload Distribution Chart
            const ctx2a = document.getElementById('workloadDistributionChart')?.getContext('2d');
            if (ctx2a && filteredData.calls.length > 0) {
                const callsPerStaff = filteredData.calls.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Create bins for histogram
                const bins = [
                    { label: '0-5', min: 0, max: 5, count: 0 },
                    { label: '5-10', min: 5, max: 10, count: 0 },
                    { label: '10-15', min: 10, max: 15, count: 0 },
                    { label: '15-20', min: 15, max: 20, count: 0 },
                    { label: '20+', min: 20, max: Infinity, count: 0 }
                ];
                
                callsPerStaff.forEach(ratio => {
                    const bin = bins.find(b => ratio >= b.min && ratio < b.max);
                    if (bin) bin.count++;
                });
                
                chartInstances.workloadDist = new Chart(ctx2a, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => b.label),
                        datasets: [{
                            label: 'Days',
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => {
                                if (b.min >= 20) return '#ef4444';
                                if (b.min >= 15) return '#f97316';
                                if (b.min >= 10) return '#eab308';
                                return '#22c55e';
                            }),
                            borderRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Number of Days'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Calls per Staff Member'
                                }
                            }
                        }
                    }
                });
            }
            
            // Staff Utilization Pattern
            const ctx2b = document.getElementById('utilizationPatternChart')?.getContext('2d');
            if (ctx2b && filteredData.calls.length > 0) {
                // Calculate weekly average patterns
                const weeklyPatterns = {};
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                filteredData.calls.forEach(row => {
                    const date = parseDate(row.Date);
                    if (date) {
                        const dayName = date.format('dddd');
                        if (!weeklyPatterns[dayName]) {
                            weeklyPatterns[dayName] = { totalRatio: 0, count: 0 };
                        }
                        const ratio = (row.total_calls || 0) / (row.total_staff_count || 1);
                        weeklyPatterns[dayName].totalRatio += ratio;
                        weeklyPatterns[dayName].count++;
                    }
                });
                
                const dayData = dayOrder.map(day => {
                    if (weeklyPatterns[day] && weeklyPatterns[day].count > 0) {
                        return weeklyPatterns[day].totalRatio / weeklyPatterns[day].count;
                    }
                    return 0;
                });
                
                chartInstances.utilization = new Chart(ctx2b, {
                    type: 'radar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Avg Calls/Staff',
                            data: dayData,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: '#3b82f6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            r: {
                                beginAtZero: true,
                                title: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            }
            
            // Call outcomes
            const ctx3 = document.getElementById('callOutcomesChart')?.getContext('2d');
            if (ctx3 && filteredData.calls.length > 0) {
                const outcomes = calculateCallOutcomes();
                
                if (Object.values(outcomes.data).some(v => v > 0)) {
                    chartInstances.callOutcomes = new Chart(ctx3, {
                        type: 'doughnut',
                        data: {
                            labels: outcomes.labels,
                            datasets: [{
                                data: outcomes.data,
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899',
                                    '#6b7280'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
            
            // Abandonment Rate Chart
            const ctx4 = document.getElementById('abandonmentRateChart')?.getContext('2d');
            if (ctx4 && filteredData.calls.length > 0) {
                const data = filteredData.calls;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                
                // Calculate abandonment rate from actual outcomes
                const abandonmentRates = data.map(row => {
                    const abandoned = row.Abandoned || 0;
                    const total = row.total_calls || 0;
                    return total > 0 ? (abandoned / total) * 100 : 0;
                });
                
                const callsPerStaff = data.map(row => (row.total_calls || 0) / (row.total_staff_count || 1));
                
                // Calculate moving average for abandonment rate
                const movingAvg = [];
                for (let i = 0; i < abandonmentRates.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = abandonmentRates.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.abandonmentRate = new Chart(ctx4, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Abandonment Rate (%)',
                                data: abandonmentRates,
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#991b1b',
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0,
                                yAxisID: 'y',
                                tension: 0.3
                            },
                            {
                                label: 'Calls per Staff',
                                data: callsPerStaff,
                                borderColor: '#6366f1',
                                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                                borderWidth: 2,
                                pointRadius: 3,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            if (context.datasetIndex === 2) {
                                                label += context.parsed.y.toFixed(1);
                                            } else {
                                                label += context.parsed.y.toFixed(1) + '%';
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Abandonment Rate (%)'
                                },
                                beginAtZero: true,
                                max: Math.max(...abandonmentRates) * 1.2 || 30
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Calls per Staff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // AHT trends
            const ctx5 = document.getElementById('ahtChart')?.getContext('2d');
            if (ctx5 && filteredData.calls.length > 0) {
                const data = filteredData.calls.filter(row => row.AHT_seconds > 0);
                
                if (data.length > 0) {
                    const dates = data.map(row => {
                        const date = parseDate(row.Date);
                        return date ? date.format('MMM DD') : '';
                    }).filter(d => d);
                    const aht = data.map(row => row.AHT_seconds || 0);
                    
                    chartInstances.aht = new Chart(ctx5, {
                        type: 'line',
                        data: {
                            labels: dates,
                            datasets: [{
                                label: 'Average Handle Time (seconds)',
                                data: aht,
                                borderColor: '#f59e0b',
                                backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create visitor charts
        function createVisitorCharts() {
            // Visitor trends
            const ctx1 = document.getElementById('visitorTrendsChart')?.getContext('2d');
            if (ctx1 && filteredData.visitors.length > 0) {
                const data = filteredData.visitors;
                const dates = data.map(row => {
                    const date = parseDate(row.Date);
                    return date ? date.format('MMM DD') : '';
                }).filter(d => d);
                const visitors = data.map(row => row.in_person_visitor_count || 0);
                
                // Calculate moving average
                const movingAvg = [];
                for (let i = 0; i < visitors.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = visitors.slice(start, i + 1);
                    const avg = subset.reduce((a, b) => a + b, 0) / subset.length;
                    movingAvg.push(avg);
                }
                
                chartInstances.visitorTrends = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Visitors',
                                data: visitors,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1
                            },
                            {
                                label: '7-Day Average',
                                data: movingAvg,
                                borderColor: '#ef4444',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            // Day of week analysis
            const ctx2 = document.getElementById('dayOfWeekChart')?.getContext('2d');
            if (ctx2 && filteredData.visitors.length > 0) {
                const dayData = analyzeDayOfWeek();
                
                if (dayData.labels.length > 0) {
                    chartInstances.dayOfWeek = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: dayData.labels,
                            datasets: [{
                                label: 'Average Visitors',
                                data: dayData.data,
                                backgroundColor: '#8b5cf6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Create intelligence charts
        function createIntelligenceCharts() {
            // Intent distribution
            const ctx1 = document.getElementById('intentChart')?.getContext('2d');
            if (ctx1 && filteredData.intelligence.length > 0) {
                const intents = analyzeIntents().slice(0, 10);
                
                if (intents.length > 0) {
                    chartInstances.intent = new Chart(ctx1, {
                        type: 'bar',
                        data: {
                            labels: intents.map(i => i.intent),
                            datasets: [{
                                label: 'Count',
                                data: intents.map(i => i.count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
            
            // Emotion analysis
            const ctx2 = document.getElementById('emotionChart')?.getContext('2d');
            if (ctx2 && filteredData.intelligence.length > 0) {
                const emotions = analyzeEmotions();
                
                if (emotions.length > 0) {
                    chartInstances.emotion = new Chart(ctx2, {
                        type: 'pie',
                        data: {
                            labels: emotions.map(e => e.emotion),
                            datasets: [{
                                data: emotions.map(e => e.count),
                                backgroundColor: [
                                    '#10b981',
                                    '#ef4444',
                                    '#f59e0b',
                                    '#3b82f6',
                                    '#8b5cf6',
                                    '#ec4899'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                }
                            }
                        }
                    });
                }
            }
        }
        
        // Helper functions
        function aggregateMonthlyData() {
            const monthly = {};
            
            // Aggregate all interactions by month
            filteredData.chatbot.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].queries += row.query_count || 0;
                }
            });
            
            filteredData.calls.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].calls += row.total_calls || 0;
                }
            });
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const month = date.format('YYYY-MM');
                    if (!monthly[month]) monthly[month] = { queries: 0, calls: 0, visitors: 0 };
                    monthly[month].visitors += row.in_person_visitor_count || 0;
                }
            });
            
            const months = Object.keys(monthly).sort();
            
            return {
                labels: months.map(m => moment(m).format('MMM YYYY')),
                totals: months.map(m => monthly[m].queries + monthly[m].calls + monthly[m].visitors)
            };
        }
        
        function calculateCallOutcomes() {
            const totals = {
                Completed: 0,
                Abandoned: 0,
                'Missed with VM': 0,
                'Missed without VM': 0,
                Other: 0,
                Transferred: 0,
                Unknown: 0
            };
            
            filteredData.calls.forEach(row => {
                totals.Completed += row.Completed || 0;
                totals.Abandoned += row.Abandoned || 0;
                totals['Missed with VM'] += row['Missed with VM'] || 0;
                totals['Missed without VM'] += row['Missed without VM'] || 0;
                totals.Other += row.Other || 0;
                totals.Transferred += row.Transferred || 0;
                totals.Unknown += row.Unknown || 0;
            });
            
            return {
                labels: Object.keys(totals),
                data: Object.values(totals)
            };
        }
        
        function analyzeDayOfWeek() {
            const dayTotals = {
                Sunday: { total: 0, count: 0 },
                Monday: { total: 0, count: 0 },
                Tuesday: { total: 0, count: 0 },
                Wednesday: { total: 0, count: 0 },
                Thursday: { total: 0, count: 0 },
                Friday: { total: 0, count: 0 },
                Saturday: { total: 0, count: 0 }
            };
            
            filteredData.visitors.forEach(row => {
                const date = parseDate(row.Date);
                if (date) {
                    const day = date.format('dddd');
                    if (dayTotals[day]) {
                        dayTotals[day].total += row.in_person_visitor_count || 0;
                        dayTotals[day].count += 1;
                    }
                }
            });
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            return {
                labels: days,
                data: days.map(day => 
                    dayTotals[day].count > 0 
                        ? Math.round(dayTotals[day].total / dayTotals[day].count)
                        : 0
                )
            };
        }
    </script>
</body>
</html>